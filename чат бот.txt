import nltk
import random

BOT_CONFIG = {
    "intents": { # Намерения
        "hello": { # Намерение поздароваться
            "examples": ["Привет", "Добрый день", "Шалом", "Здравствуйте"],
            "responses": ["Привет, человек", "Доброго времени суток"]
        },
        "bye": {
            "examples": ["Пока", "Досвидос", "Прощай"],
            "responses": ["Счастливо", "До свидания", "Если что, возвращайтесь"],
        },
        "howdoyoudo": {
            "examples": ["Как дела", "Что делаешь", "Какие дела"],
            "responses": ["Маюсь фигней", "Отвечаю на дурацкие вопросы", "Ем говно"],
        },
    },
    "failure_phrases": [
        "Я ничо не понил",
        "Что-то непонятно",
        "Я всего лишь бот, сформулируйте попроще"
    ]
}

def filter(text):
  text = text.lower()
  text = [c for c in text if c in 'абвгджзеёийклмнопрстуфхцчшщьыъэюя -']
  return ''.join(text)

def match(text, example): # "прощяй!" === "Прощай" ??
  text = filter(text)
  #example = filter(example)
  
  distance = nltk.edit_distance(text, example) / len(example)
  if distance < 0.4:
    return True # Текст совпадает
  else:
    return False # Текст НЕ совпадает

def get_intent(text): 
  for intent, data in BOT_CONFIG['intents'].items():
    for example in data['examples']:
      if match(text, example):
        return intent

def get_answer_by_intent(intent):
  phrases = BOT_CONFIG['intents'][intent]['responses']
  return random.choice(phrases)

def bot(text):
  # 1 Понять намерение
  intent = get_intent(text)

  if not intent:
    intent = get_intent_predictive_model(text)

  if intent:
    return get_answer_by_intent(intent)

  

  # 2 Отвечаем "заглушкой"
  failure_phrases = BOT_CONFIG['failure_phrases']
  return random.choice(failure_phrases)

question = ''
while question not in ['выход', 'отстань']:
  question = input()
  answer = bot(question)
  print(answer)

import json

config_file = open('/content/big_bot_config.json', "r")

BOT_CONFIG = json.load(config_file)

len(BOT_CONFIG['intents'])

BOT_CONFIG['intents']['hello']['examples']

X_examples = []
y = []
for intent, data in BOT_CONFIG['intents'].items():
  for example in data['examples']:
    X_examples.append(example)
    y.append(intent)

from sklearn.feature_extraction.text import CountVectorizer
count_vectorizer = CountVectorizer()
count_vectorizer.fit(X_examples)

X = count_vectorizer.transform(X_examples)

from sklearn.linear_model import LogisticRegression

log_reg = LogisticRegression()
log_reg.fit(X, y)

log_reg.predict(count_vectorizer.transform(['чем ты там занимаешься']))


log_reg.score(X, y)

from sklearn.svm import LinearSVC

from sklearn.feature_extraction.text import HashingVectorizer

hashing_vectorizer = HashingVectorizer()
X = hashing_vectorizer.fit_transform(X_examples)

from sklearn.feature_extraction.text import TfidfVectorizer
TFV = TfidfVectorizer(analyzer='char_wb', ngram_range=(2,4))
X = TFV.fit_transform(X_examples)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.33
)

lin_svc = LinearSVC()
lin_svc.fit(X_train, y_train)
print ('Train', lin_svc.score(X_train, y_train))
print ('Test', lin_svc.score(X_test, y_test))

def get_intent_predictive_model(text):
  return lin_svc.predict(TFV.transform([text]))[0]

import pickle

pickle.dump(lin_svc, open('lin_svc.model', 'wb'))
pickle.dump(TFV, open('TFV.model', 'wb'))

vctrzr = pickle.load(open('lin_svc.model', 'rb'))

! pip install python-telegram-bot --upgrade

from telegram import Update
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext

def start(update: Update, context: CallbackContext) -> None:
    """Send a message when the command /start is issued."""
    update.message.reply_text('Кукуськи, пуська!')


def help_command(update: Update, context: CallbackContext) -> None:
    """Send a message when the command /help is issued."""
    update.message.reply_text('Help!')


def echo(update: Update, context: CallbackContext) -> None:
    """Echo the user message."""
    answer = bot(update.message.text)
    update.message.reply_text(answer)


def main():
    """Start the bot."""
    # Create the Updater and pass it your bot's token.
    # Make sure to set use_context=True to use the new context based callbacks
    # Post version 12 this will no longer be necessary
    updater = Updater("1311062782:AAHVB0rcTMuXQjIBLSO9IJ1IzD3hFSfszhg", use_context=True)

    # Get the dispatcher to register handlers
    dispatcher = updater.dispatcher

    # on different commands - answer in Telegram
    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CommandHandler("help", help_command))

    # on noncommand i.e message - echo the message on Telegram
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, echo))

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

main()